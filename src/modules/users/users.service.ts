import { Injectable, ConflictException, NotFoundException } from '@nestjs/common';
import * as argon2 from 'argon2';
import { UsersRepository } from './users.repository';
import { CreateUserDto } from './dto/create-user.dto';
import { UserModel, ProfileModel } from './models/user.model';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
    constructor(private readonly usersRepository: UsersRepository) { }

    async create(dto: CreateUserDto): Promise<UserModel> {
        const existing = await this.usersRepository.findByEmail(dto.email);
        if (existing) throw new ConflictException('Email already exists');

        const hashedPassword = await argon2.hash(dto.password);

        const profile = new ProfileModel(
            dto.profile.firstName,
            dto.profile.lastName,
            dto.profile.address,
        );

        const newUser = new UserModel(
            undefined as unknown as string, // ID is generated by the database
            dto.email,
            true,
            new Date(),
            hashedPassword,
            profile,
        );

        return this.usersRepository.create(newUser);
    }

    async findAll() {
        return this.usersRepository.findAll();
    }

    async findOne(id: string): Promise<UserModel> {
        const user = await this.usersRepository.findById(id);
        if (!user) throw new NotFoundException(`User with ID ${id} not found`);
        return user;
    }

    async update(id: string, dto: UpdateUserDto): Promise<UserModel> {
        const user = await this.findOne(id);

        if (dto.email && dto.email !== user.email) {
            const existingEmail = await this.usersRepository.findByEmail(dto.email);
            if (existingEmail) throw new ConflictException('Email already in use');
        }

        let hashedPassword: string | undefined = undefined;
        if (dto.password) {
            hashedPassword = await argon2.hash(dto.password);
        }

        const updateData: Partial<UserModel> = {
            ...dto,
            password: hashedPassword,
            profile: dto.profile ? { ...dto.profile } : undefined
        };

        return this.usersRepository.update(id, updateData);
    }

    async remove(id: string): Promise<void> {
        const user = await this.findOne(id);
        await this.usersRepository.remove(user.id);
    }
}
